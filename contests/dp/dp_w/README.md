# 典型要素

インラインDP

# 解法

[けんちょんさんの解説](https://qiita.com/drken/items/68b8503ad4ffb469624c#6-%E3%82%A4%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3-dp%E3%81%A8%E3%81%8F%E3%81%AB-edpc-w---intervals)が分かりやすい。高速化する前の $O(N^2)$ のDPがそもそも難しいのでさらに行間を足す。

$dp[i][j]$ を以下の条件を満たすときのスコアの最大値とする。 $i$ は1-indexとする。

* $i$ 文字目まで 01を確定させた。
* 最も右にある1の場所が $j$ である。
* $[0, i]$ に完全に含まれる(つまり、 $i+1$ 文字目以降に影響されない)区間についてスコアに反映した。そうでない区間については、左端が $[0, i]$ に含まれていたとしてもスコアの加算は保留する。

$dp[i][j]$ を $i=1,2,...$ の順に計算していく。 $j$ は $i$ 以下のものを計算する。

$dp[i+1][*]$ のために $i+1$ 文字目を決定するとき、右端がちょうど $i+1$ である(これまで保留していたが今回完全に01が確定する)区間それぞれについてスコアに反映させる。

* $i+1 $文字目を0とする場合: 右端が $i+1$ である区間それぞれについて、 $j$ がその区間に含まれるような $dp[i][j]$ 全てに対して加算を保留していたスコアを反映する必要がある。具体的には、区間のスコアを $a[k]$ として $dp[i+1][j] = dp[i][j] + a[k]$ とする。
* $i+1$ 文字目を1とする場合: 右端が $i+1$ である区間は全てスコアに加算されるので、どの区間が保留されているかを無視して $dp[i][j]$ のうち最大であるものを使えばよい。具体的には $dp[i+1][j+1] = max(dp[i][*]) + sum(a[k])$ とする。
 
