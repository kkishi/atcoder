# 典型要素

インラインDP

# 解法

[けんちょんさんの解説](https://qiita.com/drken/items/68b8503ad4ffb469624c#6-%E3%82%A4%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3-dp%E3%81%A8%E3%81%8F%E3%81%AB-edpc-w---intervals)が分かりやすい。高速化する前のO(N^2)のDPがそもそも難しいのでさらに行間を足す。

`dp[i][j]`を以下の条件を満たすときのスコアの最大値とする。iは1-indexとする。

* i文字目まで01を確定させた。
* 最も右にある1の場所がjである。
* `[0, i]`に完全に含まれる(つまり、i+1文字目以降に影響されない)区間についてスコアに反映した。そうでない区間については、左端が`[0, i]`に含まれていたとしてもスコアの加算は保留する。

`dp[i][j]`をi=1,2,...の順に計算していく。jはi以下のものを計算する。

`dp[i+1][*]`のためにi+1文字目を決定するとき、右端がちょうど`i+1`である(これまで保留していたが今回完全に01が確定する)区間それぞれについてスコアに反映させる。

* i+1文字目が0であるとき: 右端が`i+1`である区間それぞれについて、jがその区間に含まれるような`dp[i][j]`に対して、加算を保留していたスコアを反映する必要がある。具体的には`dp[i+1][j] = dp[i][j] + a[k]`とする。
* i+1文字目が1であるとき: 右端が`i+1`である区間は全てスコアに加算されるので、どの区間が保留されているかを無視して`dp[i][j]`のうち最大であるものを使えばよい。具体的には`dp[i+1][j+1] = max(dp[i][*]) + sum(a[k])`とする。
