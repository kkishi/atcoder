# 典型要素

*  原始根
*  約数系包除
*  主客転倒

# 解説
*  [公式](https://atcoder.jp/contests/abc212/editorial/2289)

# 解法

以下の内容は、公式解説に行間を足したもの。

まず問題を言い換える。

> `0<=x<P`であるxそれぞれについて、整数nを用いて`x^n mod P`がとる数はいくつか？

`x=0`のときは`y=0`のみ。以下`1<=x<P`とする。

`x^n mod P`の挙動を観察すると、次の事が分かる。

>  あるnで初めて値1をとる。それまでにとる値は、全て異なる。以降循環する。

xはそれぞれ異なるnで初めて1をとる。そのようなnを[位数](https://manabitimes.jp/math/905)と呼ぶ。

例えば:

*  P=11, x=2 の場合: 2, 4, 8, 5, 10, 9, 7, 3, 6, 1 (位数10)
*  P=11, x=3 の場合: 3, 9, 5, 4, 1 (位数5)

位数を使うと問題を簡潔に言い換える事ができる。

> `0<=x<P`であるxそれぞれについて、位数を求める。それの総和はいくつか。

xの位数を効率よく計算するには、[原始根](https://manabitimes.jp/math/842)を利用する。rをPの原始根とする。(注: 原始根であればどれでも良い。Pが素数なので、必ず原始根は存在する。) rのべきは1からP-1の全ての値をとる。これを利用してxを表す。つまり、`0<=a<P-1`である整数aを用いて`x=r^a`とみなす。yも同様にして`y=r^b`とみなす。これを用いて元の式を変形すると、

> `x^n=y mod P` ⇒ `r^an=r^b mod P` ⇒ `an=b mod P-1`

これによって、以下の問題に帰着される。

> `0<=a<P-1`である`a`それぞれについて、整数`n`を用いて`an mod P-1`で表す事が出来る数はいくつか？

これは、変化する値がべきから倍数に変わったことで、元の問題よりも扱いやすくなっている。

上の議論は天下り的だったので、具体例で考える。P=11, r=2とする。x=3のとき, a=8 (2^8 mod 11 = 3)である事を用いると、3^n = (2^8)^n = 2^(8n)。8n mod 10 がとる値は、8, 6, 4, 2, 0。すなわち、3^nがとる値は5つ。

`an mod P-1`のがとりうる値は、一般的には次のように求める事が出来る。

> `an`がn=0の次に値0をとるのはan=lcm(a, P-1)のときで、それ以下では重複が無い(*)ので、`lcm(a, P-1) / a` = `(P-1)/gcd(a, P-1)`で求まる。

`a`は多くの値をとりうる(10^12)ので、主客転倒をする。

>  gcd としてありうる値それぞれについて、いくつあるか数える。

gcdとしてありえるのはP-1の約数で、これは素朴に試し割りをすることでO(sqrt(P))で求める事ができる。
それぞれのgcdの数は、約数系包除を用いてDPをすることで求められる。具体的には、`dp[gcd] = (P-1) / gcd`から`dp[gcdの倍数]`を引く。これは、gcdの倍数を列挙するときに[Divide Both](https://atcoder.jp/contests/abc206/tasks/abc206_e)と同じ方法を使うとO(P log P)となってしまうが、愚直に他の約数を全て試し割りすることでO((約数の数)^2)で求める事が出来る。

(*) 無証明
