# 典型要素

* 部分集合の列挙はO(3^N)
* bit DP

# 解説

* [公式](https://atcoder.jp/contests/abc213/editorial/2392)

# 解法

以下の内容は、公式解説に行間を足したもの。

この問題をbit DPで解こうと考えると、次の関数が素朴に思いつく。

> x(S) = Sに含まれる頂点が連結となるような場合の数


これはこのままだと扱いづらいので、次の関数を考える。`y(S)`があると`x(S)`も簡単に求まる事に注意。

> y(S) = Sに含まれる頂点が*ちょうど*連結となるような場合の数。つまり、Sの補集合をTとすると、
>
> *  Sは連結
> *  Sの要素とTの要素はいずれも連結でない
> *  Tの状態については問わない

`y(S)`は以下の２つの組み合わせで表すことが出来る。

> *  f(S) = Sからなる部分グラフ（Sに含まれる頂点のみ・S内で張られる辺のみに着目して得られるグラフ）について、それが連結となるように辺を残す場合の数。Sに含まれない頂点と張られる辺については無視する。
> *  g(S) = Sからなる部分グラフについて、辺を残す場合の数。つまり、S内で張られる辺の数をeとすると、2^e。

これらを用いると、

> y(S) = f(S) * g(V \ S)


`f(S)`は再帰的に求まる。包除原理を用いて、全て（つまり`g(S)`）から、Sが連結とならないものを引く。

天下り的だが、ここでSに含まれる要素を一つ（どれでも良い、例えば添字の一番小さな要素）選び、iとする。Sが連結でないとき、iはあるSの真部分集合Tとちょうど連結である。つまり、Tを列挙すれば良い。

具体的には次のようにする。Sを２つの部分集合に分割したとき、iが含まれる方をTとする。`f(T) * g(S \ T)`が求める数である（Sが連結でないもののうち、iがTとちょうど連結となるような場合の数）。


# 補足

「連結な無向グラフの数え上げ」であって、「連結な木の数え上げ」ではないので、行列木定理は使えない。
