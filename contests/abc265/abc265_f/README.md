# 解法 (main_lib.cc)

各次元について二次元DPをする。配るDPを考えると配る先のマスが規則的に並ぶので、累積和を用いて高速化する。以下のように/方向の更新が部分的にDP配列の範囲外となる場合に注意。

```
..... *
.....* *
....*   *
...*.
..*..
 *
*
 *
  *
```

上記の場合を吸収してmain関数が簡単になるようにライブラリを書いた。

* `CumulativeSum(int h, int w, int dr, int dc)`: $(dr, dc)$ 方向に累積和を取る $h \times w$ の二次元配列を作る。例えば $dr=-2, dc=1$ とすると右上方向に累積和を取ることになる。
* `void Add(T v, int r0, int c0, int n)`: $(r0, c0)$ を起点に $n$ マスに $v$ を足す。 $(r0, c0)$ がDP配列外である場合も適切に処理される。
* `void Eval()`: 実際に累積和を計算する。`Add`を呼び終えた後に1度だけ呼ぶ必要がある。
